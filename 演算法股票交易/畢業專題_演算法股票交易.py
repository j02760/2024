# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zg83EbEGXaw_5teT0dCbKO8-TjnqU8oM
"""

import pandas as pd
import datetime as dt
from datetime import date
import matplotlib.pyplot as plt
import yfinance as yf
import numpy as np
import tensorflow as tf

def load_data(ticker, start="2010-01-01", end=None):
    if end is None:
        end = date.today().strftime("%Y-%m-%d")
    data = yf.download(ticker, start, end)
    data.reset_index(inplace=True)
    return data

# 下載台灣股市台積電 (TSMC) 的數據
data = load_data('2330.TW')  # 台積電的股票代碼 '2330.TW'
df = data
df.head()  # 顯示前五行

df = df.drop(['Date', 'Adj Close'], axis = 1)
df.head()

import matplotlib.dates as mdates
import matplotlib.pyplot as plt

# 下載台灣股市台積電 (TSMC) 的數據
data = load_data('2330.TW')  # 台積電的股票代碼 '2330.TW'
df = data
df.head()  # 顯示前五行

# *** The fix is in this block! ***
# Instead of dropping 'Date', keep it and drop it later if needed
# df = df.drop(['Date', 'Adj Close'], axis = 1)
# df.head()

# 確保 'Date' 列是 datetime 格式
df['Date'] = pd.to_datetime(df['Date'])

plt.figure(figsize=(12, 6))

# 繪製收盤價
plt.plot(df['Date'], df['Close'])

# 設置標題和軸標籤
plt.title("TSM TW Stock Price")
plt.xlabel("Date")
plt.ylabel("Price (NTD)")

# 格式化x軸的日期顯示為月份
plt.gca().xaxis.set_major_locator(mdates.AutoDateLocator())  # 自動調整日期間隔
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))  # 設置顯示格式為 月+年

plt.grid(True)
plt.xticks(rotation=45)  # 讓日期標籤旋轉45度，避免擁擠
plt.show()

# Now you can drop the 'Date' column if you don't need it anymore:
# df = df.drop(['Date', 'Adj Close'], axis = 1)
# df.head()

df

ma100 = df.Close.rolling(100).mean()
ma100

print(df.index)

df.reset_index(drop=True, inplace=True)

import matplotlib.dates as mdates
import matplotlib.pyplot as plt

# 確保 'Date' 列是 datetime 格式
df['Date'] = pd.to_datetime(df['Date'])

plt.figure(figsize=(12, 6))

# 繪製收盤價，使用 'Date' 作為 x 軸
plt.plot(df['Date'], df['Close'], label='Close Price')

# 繪製 100 天移動平均線，假設 'ma100' 也是與日期對應的
plt.plot(df['Date'], ma100, 'r', label='100-Day Moving Average')

# 格式化 x 軸為日期
plt.gca().xaxis.set_major_locator(mdates.AutoDateLocator())  # 自動調整日期間隔
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))  # 設置顯示格式為 YYYY-MM-DD

plt.grid(True)
plt.title('Graph Of Moving Averages Of 100 Days')
plt.xlabel('Date')  # x 軸標籤
plt.ylabel('Price (NTD)')  # y 軸標籤
plt.xticks(rotation=45)  # 旋轉 x 軸標籤以提高可讀性
plt.legend()  # 顯示圖例
plt.show()

ma200 = df.Close.rolling(200).mean()
ma200

import matplotlib.dates as mdates
import matplotlib.pyplot as plt

# 確保 'Date' 列是 datetime 格式
df['Date'] = pd.to_datetime(df['Date'])

plt.figure(figsize=(12, 6))

# 繪製收盤價，使用 'Date' 作為 x 軸
plt.plot(df['Date'], df['Close'], label='Close Price')

# 繪製 200 天移動平均線，假設 'ma200' 也是與日期對應的
plt.plot(df['Date'], ma200, 'r', label='100-Day Moving Average')

# 格式化 x 軸為日期
plt.gca().xaxis.set_major_locator(mdates.AutoDateLocator())  # 自動調整日期間隔
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))  # 設置顯示格式為 YYYY-MM-DD

plt.grid(True)
plt.title('Graph Of Moving Averages Of 200 Days')
plt.xlabel('Date')  # x 軸標籤
plt.ylabel('Price (NTD)')  # y 軸標籤
plt.xticks(rotation=45)  # 旋轉 x 軸標籤以提高可讀性
plt.legend()  # 顯示圖例
plt.show()

df.shape

# Splitting data into training and testing

train = pd.DataFrame(data[0:int(len(data)*0.70)])
test = pd.DataFrame(data[int(len(data)*0.70): int(len(data))])

print(train.shape)
print(test.shape)
#這段程式碼的主要功能是將數據集劃分為訓練集和測試集，訓練集佔 70%，
#測試集佔 30%。這種劃分方式有助於在機器學習模型中進行訓練與評估，
#確保模型能夠泛化到未見過的數據。train.shape 和 test.shape 提供了對這些數據集大小的快速檢查，以確認劃分的正確性。

train.head()

test.head()

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0,1))
#這段程式碼的目的是設置數據標準化工具，使用 MinMaxScaler
#將數據縮放到指定的範圍 (0 到 1)。這樣在後續的數據處理和建模過程中，
#可以確保特徵之間的比較更加合理，有助於提高模型的性能和穩定性。

train_close = train.iloc[:, 4:5].values
test_close = test.iloc[:, 4:5].values
#這兩行程式碼的主要功能是從訓練集和測試集中提取收盤價格（假設位於第 4 列），
#並將這些數據轉換為 NumPy 陣列格式，以便後續進行數據處理或模型訓練。NumPy 陣列是一種高效的數據結構，特別適合數學計算和數據分析。

data_training_array = scaler.fit_transform(train_close)
data_training_array
#這行程式碼的主要功能是對訓練集的收盤價格數據進行縮放，
#將其轉換到[0, 1]的範圍內，並將結果存儲在data_training_array中。這是數據預處理過程中的一個重要步驟，有助於提高機器學習模型的性能和收斂速度。

x_train = []
y_train = []

for i in range(100, data_training_array.shape[0]):
    x_train.append(data_training_array[i-100: i])
    y_train.append(data_training_array[i, 0])

x_train, y_train = np.array(x_train), np.array(y_train)
#這段程式碼的目的是創建訓練數據集，x_train
#包含每個時間步的前 100 個收盤價格作為特徵，y_train
#包含當前時間步的收盤價格作為標籤。
#這種時間序列的數據結構適合於使用循環神經網絡（RNN）等模型進行預測。
#最終，這些列表被轉換為 NumPy 陣列，以方便進行後續的模型訓練。

x_train.shape

from tensorflow.keras.layers import Dense, Dropout, LSTM
from tensorflow.keras.models import Sequential
#這段程式碼的目的是從 Keras 庫中導入構建深度學習模型所需的基本組件。
#Dense 層用於輸出，Dropout 層用於防止過擬合，而 LSTM 層則用於處理時間序列數據。
#Sequential 模型則提供了一種簡單的方式來逐層構建網絡。這些組件將在後續的模型構建過程中使用，以實現特定的預測任務。

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, LSTM

model = Sequential()
model.add(LSTM(units = 50, activation = 'relu', return_sequences=True
              ,input_shape = (x_train.shape[1], 1)))
model.add(Dropout(0.2))


model.add(LSTM(units = 60, activation = 'relu', return_sequences=True))
model.add(Dropout(0.3))


model.add(LSTM(units = 80, activation = 'relu', return_sequences=True))
model.add(Dropout(0.4))


model.add(LSTM(units = 120, activation = 'relu'))
model.add(Dropout(0.5))

model.add(Dense(units = 1))
#這段程式碼構建了一個具有多層 LSTM 的深度學習模型，用於時間序列數據的預測。
#模型中使用了 Dropout 層來減少過擬合，並且最後添加了一個全連接層來輸出預測結果。
#通過調整每個層的單元數和 Dropout 比例，可以對模型的性能進行微調，以達到更好的預測效果。

model.summary()

import tensorflow as tf
model.compile(optimizer = 'adam', loss = 'mean_squared_error', metrics=[tf.keras.metrics.MeanAbsoluteError()])
model.fit(x_train, y_train,epochs = 5)
#這段程式碼的主要功能是編譯和訓練 LSTM 模型。首先，通過 model.compile() 設置優化器、損失函數和評估指標。
#接著，使用 model.fit() 開始訓練，提供訓練數據和訓練輪次。通過這個過程，模型會根據訓練數據進行學習，調整其權重，以最小化損失函數，從而提高預測準確性。

model.save('keras_model.keras')
#這行程式碼的主要功能是將訓練好的 Keras 模型保存到檔案中，便於未來的重用和管理。
#這是機器學習工作流中一個重要的步驟，有助於提升模型的使用效率和靈活性。

test_close.shape
#這行程式碼的目的是檢查 test_close 陣列的形狀，通過這個檢查，可以了解測試數據的結構和大小，從而確保後續操作的正確性。

past_100_days = pd.DataFrame(train_close[-100:])

test_df = pd.DataFrame(test_close)

import pandas as pd

final_df = pd.concat([past_100_days, test_df], ignore_index=True)
#final_df = past_100_days.append(test_df, ignore_index = True)

final_df.head()

input_data = scaler.fit_transform(final_df)
input_data

input_data.shape

x_test = []
y_test = []
for i in range(100, input_data.shape[0]):
   x_test.append(input_data[i-100: i])
   y_test.append(input_data[i, 0])

x_test, y_test = np.array(x_test), np.array(y_test)
print(x_test.shape)
print(y_test.shape)

# Making predictions

y_pred = model.predict(x_test)

y_pred.shape

y_test

y_pred

scaler.scale_

scale_factor = 1/0.00041967
y_pred = y_pred * scale_factor
y_test = y_test * scale_factor

plt.figure(figsize = (12,6))
plt.plot(y_test, 'b', label = "Original Price")
plt.plot(y_pred, 'r', label = "Predicted Price")
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.grid(True)
plt.show()
#這段程式碼的目的是用於比較實際價格與預測價格的圖表，通過可視化來評估模型的預測能力。使用不同的顏色來區分原始價格和預測價格，並加上相應的標籤和網格，提高了圖形的可讀性和專業性。

from sklearn.metrics import mean_absolute_error

mae = mean_absolute_error(y_test, y_pred)
mae_percentage = (mae / np.mean(y_test)) * 100
print("Mean absolute error on test set: {:.2f}%".format(mae_percentage))

from sklearn.metrics import r2_score

# Actual values
actual = y_test

# Predicted values
predicted = y_pred

# Calculate the R2 score
r2 = r2_score(actual, predicted)

print("R2 score:", r2)

# Plotting the R2 score
fig, ax = plt.subplots()
ax.barh(0, r2, color='skyblue')
ax.set_xlim([-1, 1])
ax.set_yticks([])
ax.set_xlabel('R2 Score')
ax.set_title('R2 Score')

# Adding the R2 score value on the bar
ax.text(r2, 0, f'{r2:.2f}', va='center', color='black')

plt.show()

plt.scatter(actual, predicted)
plt.plot([min(actual), max(actual)], [min(predicted), max(predicted)], 'r--')
plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.title(f'R2 Score: {r2:.2f}')
plt.show()